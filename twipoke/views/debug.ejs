<!DOCTYPE html>
<html>
  <head>
    <title>twipoke</title>
    <link rel="stylesheet" href="/stylesheets/matchRoom.css">
    <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
  <body>

    <div id="fixedScreen" class="fixedScreen">
        <!-- 戦闘画面 -->
        <div id="battleScreen" class="battleScreenContainer">
            <div id="enemyFollower" class="enemyFollowerContainer">
                <div class="enemyFollowerInfo">
                    <p id="enemyName"></p>
                    <div class="hpAndTypeContent">
                        <div class="hpGauge"><span>HP</span><div id="enemyHPGauge" class="enemyGauge"><div id="remainingEnemyHP" class="remainingEnemyHP"></div></div></div>
                        <p class="typeContent"><span id="enemyType"></span><span id="enemyHP"></span>/<span id="enemyMaxHP"></span></p>
                    </div>
                </div>
                <div class="followerIconContainer">
                    <img id="enemyIcon" class="followerIcon">
                    <div class="ground"></div>
                </div>
            </div>
            <div id="myFollower" class="followerContainer" data-follower="<%= followers[0] %>" data-followerattack="<%= followerObj[followers[0]].attack %>" data-followerdefense="<%= followerObj[followers[0]].defense %>">
                <div class="followerIconContainer">
                    <img id="myIcon" class="followerIcon" src="<%= followerObj[followers[0]].image %>">
                    <div class="ground"></div>
                </div>
                <div class="myFollowerInfo">
                    <p id="myName"><%= followerObj[followers[0]].name %></p>
                    <div class="hpAndTypeContent">
                        <div class="hpGauge"><span>HP</span><div id="myHPGauge" class="myGauge"><div id="remainingMyHP" class="remainingMyHP"></div></div></div>
                        <p class="typeContent"><span id="myType"><%= followerObj[followers[0]].followerType %></span><span id="myHP"><%= followerObj[followers[0]].hp %></span>/<span id="myMaxHP"><%= followerObj[followers[0]].hp %></span></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- イベントログ -->
        <div id="eventLog" class="eventLogContent">対戦相手の入室を待機中...</div>

        <!-- 行動選択ボタン -->
        <div id="selectBtn" class="selectActionContainer" data-follower="<%= followers[0] %>">
            <button id="followersBtn" class="followerSelectBtn btn" disabled>フォロワー</button>
            <button id="skillsBtn" class="skillSelectBtn btn" disabled>たたかう</button>
        </div>
    </div>

    <div id="action" class="actionContainer">
        <!-- フォロワー選択 -->
        <div id="followers" class="followers">
            <% Object.keys(followerObj).forEach((key, index) => { %>
                <div id="<%= key %>" class="followersContainer">
                    <div class="dammyContainer" data-containertype="follower" data-follower="<%= key %>" data-name="<%= followerObj[key].name %>" data-image="<%= followerObj[key].image %>" data-type="<%= followerObj[key].followerType %>" data-maxhp="<%= followerObj[key].hp %>" data-hp="<%= followerObj[key].hp %>" data-attack="<%= followerObj[key].attack %>" data-defense="<%= followerObj[key].defense %>"></div>
                    <% const value = followerObj[key] %>
                    <div class="followerStatusContainer">
                        <img src="<%= value.image %>">
                        <div class="followerInfo">
                            <div class="followerHead">
                                <p class="followerName"><%= value.name %></p>
                                <p class="followerType">タイプ: <%= value.followerType %></p>
                            </div>
                            <div class="followerStatus">
                                <div class="status">
                                    <span>HP</span>
                                    <span id="<%= key %>HP"><%= value.hp %></span>
                                </div>
                                <div class="status">
                                    <span>こうげき</span>
                                    <span><%= value.attack %></span>
                                </div>
                                <div class="status">
                                    <span>ぼうぎょ</span>
                                    <span><%= value.defense %></span>
                                </div>
                                <div class="status">
                                    <span>すばやさ</span>
                                    <span><%= value.speed %></span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <% for (var i = 0; i < 4; i++) { %>
                    <% const skillNum = 'tweet' + i; %>
                    <% const skill = followerObj[key][skillNum] %>
                    <% const accuracy = (skill.accuracy >= 100) ? 100 : skill.accuracy %>
                    <div class="skill">
                        <p><%= skill.tweet %></p>
                        <p>タイプ: <%= skill.type %></p>
                        <p>こうげきりょく: <%= skill.attack %></p>
                        <p>めいちゅうりつ: <%= accuracy %></p>
                    </div>
                    <% } %>
                </div>
            <% }); %>
        </div>
        
        <!-- わざ選択 -->
        <% followers.forEach((follower, key) => { %>
            <div id="<%= follower %>skills" class="skillsContainer">
                <% for (var i = 0; i < 4; i++) { %>
                <% const skillNum = 'tweet' + i; %>
                <% const skill = followerObj[follower][skillNum] %>
                <% const accuracy = (skill.accuracy >= 100) ? 100 : skill.accuracy %>
                <div id="<%= follower %>skill<%= i %>" class="skill">
                    <div class="dammyContainer" data-containertype="skill" data-follower="follower<%= key %>" data-followerattack="<%= followerObj[follower].attack %>" data-skill="<%= skillNum %>" data-tweet="<%= skill.tweet %>" data-type="<%= skill.type %>" data-attack="<%= skill.attack %>" data-accuracy="<%= accuracy %>" data-speed="<%= followerObj[follower].speed %>"></div>
                    <p><%= skill.tweet %></p>
                    <p>タイプ: <%= skill.type %></p>
                    <p>こうげきりょく: <%= skill.attack %></p>
                    <p>めいちゅうりつ: <%= accuracy %></p>
                </div>
                <% } %>
            </div>
        <% }); %>

    </div>

    <!-- 行動決定ボタン -->
    <button id="enterBtn" class="enterBtn btn" disabled>決定する</button>

    <script src="/socket.io.js"></script>
    <script>
        // socket.ioで使う定義値----------------------------------------------
        var socket = io();
        var isMerge = false; //相互処理に使う待機状態解除フラグ
        var priority = null; //行動の優先順位を決定する
        const roomID = <%= roomID %>;
        const twitterName = '<%= twitterName %>';
        // -----------------------------------------------------------------
        const weakTypeCompatibility = { // keyが攻撃側、valueが受け側
            fire: 'grass',
            water: 'fire',
            electric: 'water',
            grass: 'water',
            twi: 'normal'
        };
        const strongTypeCompatibility = {
            fire: 'water',
            water: 'grass',
            electric: 'grass',
            grass: 'fire',
            twi: 'twi'
        };
        const myName = document.getElementById('myName');
        const myIcon = document.getElementById('myIcon');
        const myType = document.getElementById('myType');
        const myHP = document.getElementById('myHP');
        const myMaxHP = document.getElementById('myMaxHP');
        const myHPGauge = document.getElementById('myHPGauge');
        const remainingMyHP = document.getElementById('remainingMyHP');
        const followerName = myName.textContent;
        const followerImg = myIcon.getAttribute('src');
        const followerType = myType.textContent;
        const followerHP = myHP.textContent;
        const followerMaxHP = myMaxHP.textContent;
        const enemyName = document.getElementById('enemyName');
        const enemyIcon = document.getElementById('enemyIcon');
        const enemyType = document.getElementById('enemyType');
        const enemyHP = document.getElementById('enemyHP');
        const enemyMaxHP = document.getElementById('enemyMaxHP');
        const enemyHPGauge = document.getElementById('enemyHPGauge');
        const remainingEnemyHP = document.getElementById('remainingEnemyHP');
        // -----------------------------------------------------------------
        const fixedScreen = document.getElementById('fixedScreen');
        const eventLog = document.getElementById('eventLog');
        const selectBtn = document.getElementById('selectBtn');
        const followersBtn = document.getElementById('followersBtn');
        const skillsBtn = document.getElementById('skillsBtn');
        const actionContainer = document.getElementById('action');
        const followersElement = document.getElementById('followers');
        const enterBtn = document.getElementById('enterBtn');
        const myFollower = document.getElementById('myFollower');
        const enemyFollower = document.getElementById('enemyFollower');
        var followerKey = myFollower.dataset.follower;

        // setTimeOut
        const setTimeOut = async () => {
            await new Promise((resolve) => setTimeout(resolve, 2000));
        };

        // フォロワーボタンを押したら手持ちのフォロワーを選択する画面を表示非表示切り替えする関数
        const followersShowToggle = (e) => {
            const toggledElementID = e.target.parentNode.dataset.follower;
            const skillsElementID = toggledElementID + 'skills';
            const skillsElement = document.getElementById(skillsElementID);
            if (followersElement.classList.contains('followersShowToggle') === true) {
                enterBtn.style.display = 'none';
            } else {
                enterBtn.style.display = 'block';
            }
            followersElement.classList.toggle('followersShowToggle');
            actionContainer.style.marginTop = window.getComputedStyle(fixedScreen).getPropertyValue('height');
            // わざ選択画面が表示中なら非表示にする
            if (skillsElement.classList.contains('skillsShowToggle') === true) {
                skillsElement.classList.toggle('skillsShowToggle');
            }
        };

        // たたかうボタンを押したらわざを選択する画面を表示非表示切り替えする関数
        const skillsShowToggle = (e) => {
            const followerID = e.target.parentNode.dataset.follower;
            const toggledElementID = followerID + 'skills';
            const toggledElement = document.getElementById(toggledElementID);
            if (toggledElement.classList.contains('skillsShowToggle') === true) {
                enterBtn.style.display = 'none';
            } else {
                enterBtn.style.display = 'block';
            }
            toggledElement.classList.toggle('skillsShowToggle');
            actionContainer.style.marginTop = window.getComputedStyle(fixedScreen).getPropertyValue('height');
            // フォロワー選択画面が表示中なら非表示にする
            if (followersElement.classList.contains('followersShowToggle') === true) {
                followersElement.classList.toggle('followersShowToggle');
            }
        };

        // フォロワーまたはわざを選択した際にフォーカスし、行動決定ボタンに必要なデータセットを渡す関数
        const selectAction = (e) => {
            const actionDataset = e.target.dataset;
            const enterBtnDataset = enterBtn.dataset;
            const selectedElement = e.target.parentNode;
            // 意図しない要素をクリックした際の誤作動防止
            if (selectedElement.classList.contains('skill') || selectedElement.classList.contains('followersContainer')) {
                const existSelected= document.getElementsByClassName('selected');
                // 戦闘参加中のフォロワーを選択したなら決定ボタンをアクティブにしない
                if (actionDataset.containertype === 'follower' && followerKey === actionDataset.follower) {
                    enterBtn.style.backgroundColor = '#a8a8a8';
                    enterBtn.disabled = true;
                } else {
                    enterBtn.style.backgroundColor = '#2f2f2f'
                    enterBtn.disabled = false;
                }
                // 選択したフォロワー・わざにフォーカスする
                if (existSelected.length === 0) {
                    selectedElement.classList.add('selected');
                } else {
                    existSelected[0].classList.remove('selected');
                    selectedElement.classList.add('selected');
                }
                // 行動決定ボタンにデータセットを追加
                Object.keys(enterBtnDataset).forEach(key => {
                    delete enterBtnDataset[key];
                });
                Object.keys(actionDataset).forEach(key => {
                    enterBtn.dataset[key] = actionDataset[key];
                });
            } else {
                return
            }
        };

        // 対戦部屋の専用ルームを建てる
        socket.emit('joinMatchRoom', {
            twitterName,
            roomID,
            followerName,
            followerImg,
            followerType,
            followerHP,
            followerAttack: myFollower.dataset.followerattack,
            followerDefense: myFollower.dataset.followerdefense
        });

        // ルーム入室後に相手のフォロワー情報を取得
        socket.on('setEnemyFollower', async (data) => {
            if (isMerge === false) {
                document.getElementById('enemyFollower').style.opacity = 1;
                enemyName.textContent = data.enemyName;
                enemyIcon.setAttribute('src', data.enemyImg);
                enemyType.textContent = data.enemyType;
                enemyHP.textContent = data.enemyHP;
                enemyMaxHP.textContent = data.enemyHP;
                enemyFollower.dataset.enemyattack = data.enemyAttack;
                enemyFollower.dataset.enemydefense = data.enemyDefense;
                eventLog.innerHTML = data.twitterName + 'が勝負を仕掛けてきた!<br>' + data.twitterName + 'は' + data.enemyName + 'をくりだした!';
                isMerge = true;
                socket.emit('sendMyFollower', {
                    twitterName,
                    roomID,
                    followerName,
                    followerImg,
                    followerType,
                    followerHP,
                    followerAttack: myFollower.dataset.followerattack,
                    followerDefense: myFollower.dataset.followerdefense
                });
            } else if (isMerge === true) {
                isMerge = false;
                await setTimeOut();
                selectBtn.style.opacity = 1;
                followersBtn.disabled = false;
                skillsBtn.disabled = false;
                eventLog.innerHTML = twitterName + 'はどうする?';
                socket.emit('changeIsMerge', {
                    roomID
                });
            }
        });

        // 待機状態解除時のループを回避する処理
        socket.on('loopStop', () => {
            isMerge = false;
            selectBtn.style.opacity = 1;
            followersBtn.disabled = false;
            skillsBtn.disabled = false;
            eventLog.innerHTML = twitterName + 'はどうする?';
        });

        // 行動決定ボタンを押下した時に発火する関数
        const enterAction = (e) => {
            const enterBtnDataset = enterBtn.dataset;
            const selected = document.getElementsByClassName('selected');
            const skillsToggle = document.getElementsByClassName('skillsShowToggle');
            const followersToggle = document.getElementsByClassName('followersShowToggle');
            skillsToggle.length ? skillsToggle[0].classList.remove('skillsShowToggle') : followersToggle[0].classList.remove('followersShowToggle');
            selected[0].classList.remove('selected');
            enterBtn.disabled = true;
            enterBtn.style.backgroundColor = '#a8a8a8';
            enterBtn.style.display = 'none';
            selectBtn.style.opacity = 0.2;
            followersBtn.disabled = true;
            skillsBtn.disabled = true;
            isMerge = false;
            eventLog.textContent = '相手の操作を待機中...';
            socket.emit('waiting', {
                dataset: enterBtnDataset,
                roomID
            });
        };

        // 戦闘中フォロワーの現在のHPを「フォロワー」一覧に反映させる関数
        const currentHP = () => {
            const currentFollowerNum = myFollower.dataset.follower;
            const currentFollowerHP = currentFollowerNum + 'HP';
            const currentFollower = document.getElementById(currentFollowerNum);
            document.getElementById(currentFollowerHP).textContent = myHP.textContent;
            currentFollower.firstChild.nextSibling.dataset.hp = myHP.textContent;
        }

        // 互いの行動が確定した際の処理------------------------------------------------------------------------------------------------------------------
        // 自分・相手のフォロワー交換処理関数
        const changeMyFollower = async (name, icon, type, hp, maxhp, follower, attack, defense) => {
            currentHP();
            myName.textContent = name;
            myIcon.setAttribute('src', icon);
            myType.textContent = type;
            myHP.textContent = hp;
            myMaxHP.textContent = maxhp;
            myFollower.dataset.follower = follower;
            myFollower.dataset.followerattack = attack;
            myFollower.dataset.followerdefense = defense;
            remainingMyHP.style.width = (myHPGauge.clientWidth * (Number(myHP.textContent) / Number(myMaxHP.textContent))) + 'px';
            followerKey = follower;
            selectBtn.dataset.follower = follower;
            eventLog.innerHTML = myName.textContent + 'を戻した!<br>いけ! ' + name + '!';
            await setTimeOut();
        };
        const changeEnemyFollower = async (name, icon, type, hp, maxhp, attack, defense) => {
            enemyName.textContent = name;
            enemyIcon.setAttribute('src', icon);
            enemyType.textContent = type;
            enemyHP.textContent = hp;
            enemyMaxHP.textContent = maxhp;
            enemyFollower.dataset.enemyattack = attack;
            enemyFollower.dataset.enemydefense = defense;
            remainingEnemyHP.style.width = (enemyHPGauge.clientWidth * (Number(enemyHP.textContent) / Number(enemyMaxHP.textContent))) + 'px';
            eventLog.innerHTML = '相手は' + enemyName.textContent + 'を戻して<br>' + name + 'をくりだした!';
            await setTimeOut();
        };
        
        // 命中処理関数
        const hit = (accuracy) => {
            const accuracyNum = Number(accuracy);
            const hitRate = Math.floor(Math.random() * (101 - 1)) + 1;
            if (hitRate <= accuracyNum) {
                return true;
            } else {
                return false;
            }
        };
        // こうげきが当たらなかった場合のイベントログ
        const missLog = async (name) => {
            eventLog.innerHTML = name + 'のこうげき!';
            await setTimeOut();
            eventLog.innerHTML = 'しかし ' + name + ' のこうげきは外れてしまった!';
        };
        // ダメージ計算関数
        const damageCalculation = (followerAttack, skillAttack, enemyDefense, isSameType, weakType) => {
            const randomNum = (Math.floor(Math.random() * (100 - 85)) + 85) / 100;
            const damage = Math.floor( (12 * followerAttack * skillAttack * isSameType * weakType * randomNum) / (enemyDefense * 50) );
            return damage;
        };
        // タイプ相性確認関数
        const attackDamage = async (attackerName, attackerType, defenderType, attackerAttack, defenderDefense, tweet, skilltype, skillattack) => {
            const isSameType = (attackerType === skilltype) ? 1.5 : 1;
            const weakType = () => {
                const weakTypeCompatibilityKeys = Object.keys(weakTypeCompatibility);
                const strongTypeCompatibilityKeys = Object.keys(strongTypeCompatibility);
                for (const key of weakTypeCompatibilityKeys) {
                    if (key === skilltype && weakTypeCompatibility[key] === defenderType) {
                        return 2;
                    }
                };
                for (const key of strongTypeCompatibilityKeys) {
                    if (key === skilltype && strongTypeCompatibility[key] === defenderType) {
                        return 0.5;
                    }
                };
                return 1;
            };
            if (weakType() === 2) {
                eventLog.innerHTML = attackerName + ' の ' + tweet + ' こうげき!<br>効果は抜群だ!';
            } else if (weakType() === 0.5) {
                eventLog.innerHTML = attackerName + ' の ' + tweet + ' こうげき!<br>効果はいまひとつのようだ...';
            } else {
                eventLog.innerHTML = attackerName + ' の ' + tweet + ' こうげき!';
            }
            await setTimeOut();
            const attack = Number(attackerAttack);
            const defense = Number(defenderDefense);
            const damage = damageCalculation(attack, Number(skillattack), defense, isSameType, weakType());
            return damage;
        };

        // ダメージを画面に反映させる関数
        const reflectDamage = (damage, hp, maxhp, hpGauge, remainingHP) => {
            const afterHP = Number(hp.textContent) - damage;
            if (afterHP <= 0) {
                hp.textContent = 0;
                currentHP();
                remainingHP.style.width = '0px';
                return false;
            } else {
                hp.textContent = afterHP;
                currentHP();
                const hpGaugeWidth = hpGauge.clientWidth;
                const remainingHPWidth = remainingHP.clientWidth;
                const afterHPGaugeWidth = remainingHPWidth - damage * (Number(hpGaugeWidth) / Number(maxhp));
                remainingHP.style.width = afterHPGaugeWidth + 'px';
                return true;
            }
        };

        // こうげきを受けてHPが0になった時の処理
        const dying = async (dyingFollower, follower) => {
            eventLog.innerHTML = dyingFollower + ' は倒れた!';
            await setTimeOut();
            follower.style.opacity = 0;
            await setTimeOut();
            eventLog.innerHTML = '次に戦わせるフォロワーを選んでください';
            selectBtn.style.opacity = 0.2;
            followersBtn.disabled = true;
            skillsBtn.disabled = true;
            enterBtn.style.display = 'block';
            followersElement.classList.toggle('followersShowToggle');
            actionContainer.style.marginTop = window.getComputedStyle(fixedScreen).getPropertyValue('height');
        }

        // 行動開始socket
        socket.on('actionStart', async (data) => {
            const myDataset = enterBtn.dataset;
            const enemyDataset = data.dataset;
            // 互いの行動がフォロワー入れ替えかこうげきか判別して行動の優先順位をつける
            if (myDataset.containertype === 'follower') {
                if (enemyDataset.containertype === 'follower') {
                    priority = (Number(myDataset.hp) > Number(enemyDataset.hp)) ? true : false;
                    if (priority === true) {
                        // 双方フォロワー交換 -> 先攻
                        await changeMyFollower(
                            myDataset.name,
                            myDataset.image,
                            myDataset.type,
                            myDataset.hp,
                            myDataset.maxhp,
                            myDataset.follower,
                            myDataset.attack,
                            myDataset.defense
                        );
                        await changeEnemyFollower(
                            enemyDataset.name,
                            enemyDataset.image,
                            enemyDataset.type,
                            enemyDataset.hp,
                            enemyDataset.maxhp,
                            enemyDataset.attack,
                            enemyDataset.defense
                        );
                        socket.emit('checkProcessed', {
                            myDataset,
                            roomID
                        });
                    } else {
                        // 双方フォロワー交換 -> 後攻
                        await changeEnemyFollower(
                            enemyDataset.name,
                            enemyDataset.image,
                            enemyDataset.type,
                            enemyDataset.hp,
                            enemyDataset.maxhp,
                            enemyDataset.attack,
                            enemyDataset.defense
                        );
                        await changeMyFollower(
                            myDataset.name,
                            myDataset.image,
                            myDataset.type,
                            myDataset.hp,
                            myDataset.maxhp,
                            myDataset.follower,
                            myDataset.attack,
                            myDataset.defense
                        );
                        socket.emit('checkProcessed', {
                            myDataset,
                            roomID
                        });
                    }
                } else if (enemyDataset.containertype === 'skill') {
                    console.log('follower:skill -> 先攻');
                    // フォロワー交換：こうげき -> 先攻
                    await changeMyFollower(
                        myDataset.name,
                        myDataset.image,
                        myDataset.type,
                        myDataset.hp,
                        myDataset.maxhp,
                        myDataset.follower,
                        myDataset.attack,
                        myDataset.defense
                    );
                    await setTimeOut();
                    if (hit(enemyDataset.accuracy) === true) {
                        const damageReceived = await attackDamage(
                            enemyName.textContent,
                            enemyType.textContent,
                            myType.textContent,
                            enemyFollower.dataset.enemyattack,
                            myFollower.dataset.followerdefense,
                            enemyDataset.tweet,
                            enemyDataset.type,
                            enemyDataset.attack
                        );
                        await reflectDamage(damageReceived, myHP, myMaxHP.textContent, myHPGauge, remainingMyHP);
                    } else {
                        await missLog(enemyName.textContent);
                    }
                }
            } else if (myDataset.containertype === 'skill') {
                if (enemyDataset.containertype === 'follower') {
                    console.log('skill:follower -> 後攻');
                    // フォロワー交換：こうげき -> 後攻
                    await changeEnemyFollower(
                        enemyDataset.name,
                        enemyDataset.image,
                        enemyDataset.type,
                        enemyDataset.hp,
                        enemyDataset.maxhp,
                        enemyDataset.attack,
                        enemyDataset.defense
                    );
                    setTimeOut();
                    if (hit(myDataset.accuracy) === true) {
                            const damageDone = await attackDamage(
                                myName.textContent,
                                myType.textContent,
                                enemyType.textContent,
                                myFollower.dataset.followerattack,
                                enemyFollower.dataset.enemydefense,
                                myDataset.tweet,
                                myDataset.type,
                                myDataset.attack
                            );
                        await reflectDamage(damageDone, enemyHP, enemyMaxHP.textContent, enemyHPGauge, remainingEnemyHP);
                    } else {
                        await missLog(myName.textContent);
                    }
                } else if (enemyDataset.containertype === 'skill') {
                    priority = (Number(myDataset.speed) > Number(enemyDataset.speed)) ? true : false;
                    if (priority === true) {
                        console.log('skill:skill -> 先攻');
                        // 双方こうげき -> 先攻
                        if (hit(myDataset.accuracy) === true) {
                            const damageDone = await attackDamage(
                                myName.textContent,
                                myType.textContent,
                                enemyType.textContent,
                                myFollower.dataset.followerattack,
                                enemyFollower.dataset.enemydefense,
                                myDataset.tweet,
                                myDataset.type,
                                myDataset.attack
                            );
                            const reflect = await reflectDamage(damageDone, enemyHP, enemyMaxHP.textContent, enemyHPGauge, remainingEnemyHP);
                            if (reflect === false) {
                                // socketでHP0になった側のフォロワー入れ替えへ移行
                                console.log('HPが0になったよ!');
                            }
                        } else {
                            await missLog(myName.textContent);
                        }
                        await setTimeOut();
                        if (hit(enemyDataset.accuracy) === true) {
                            const damageReceived = await attackDamage(
                                enemyName.textContent,
                                enemyType.textContent,
                                myType.textContent,
                                enemyFollower.dataset.enemyattack,
                                myFollower.dataset.followerdefense,
                                enemyDataset.tweet,
                                enemyDataset.type,
                                enemyDataset.attack
                            );
                            const reflect = await reflectDamage(damageReceived, myHP, myMaxHP.textContent, myHPGauge, remainingMyHP);
                            if (reflect === false) {
                                // socketでHP0になった側のフォロワー入れ替えへ移行
                                console.log('HPが0になったよ!');
                                dying(myName.textContent, myFollower);
                                return
                            }
                        } else {
                            await missLog(enemyName.textContent);
                        }
                        socket.emit('checkProcessed', {
                            myDataset,
                            roomID
                        });
                    } else {
                        console.log('skill:skill -> 後攻');
                        // 双方こうげき -> 後攻
                        if (hit(enemyDataset.accuracy) === true) {
                            const damageReceived = await attackDamage(
                                enemyName.textContent,
                                enemyType.textContent,
                                myType.textContent,
                                enemyFollower.dataset.enemyattack,
                                myFollower.dataset.followerdefense,
                                enemyDataset.tweet,
                                enemyDataset.type,
                                enemyDataset.attack
                            );
                            const reflect = await reflectDamage(damageReceived, myHP, myMaxHP.textContent, myHPGauge, remainingMyHP);
                            if (reflect === false) {
                                // socketでHP0になった側のフォロワー入れ替えへ移行
                                console.log('HPが0になったよ!');
                                dying(myName.textContent, myFollower);
                                return
                            }
                        } else {
                            await missLog(enemyName.textContent);
                        }
                        await setTimeOut();
                        if (hit(myDataset.accuracy) === true) {
                            const damageDone = await attackDamage(
                                myName.textContent,
                                myType.textContent,
                                enemyType.textContent,
                                myFollower.dataset.followerattack,
                                enemyFollower.dataset.enemydefense,
                                myDataset.tweet,
                                myDataset.type,
                                myDataset.attack
                            );
                            const reflect = await reflectDamage(damageDone, enemyHP, enemyMaxHP.textContent, enemyHPGauge, remainingEnemyHP);
                            if (reflect === false) {
                                // socketでHP0になった側のフォロワー入れ替えへ移行
                                console.log('HPが0になったよ!');
                            }
                        } else {
                            await missLog(myName.textContent);
                        }
                        socket.emit('checkProcessed', {
                            myDataset,
                            roomID
                        });
                    }
                }
            }
        });

        // 1ターンの最後の処理、ループ解除
        socket.on('actionEnd', async () => {
            if (isMerge === true) {
                console.log('1ターン終わり');
                eventLog.innerHTML = twitterName + ' はどうする?';
                return
            } else {
                isMerge = true;
                selectBtn.style.opacity = 1;
                followersBtn.disabled = false;
                skillsBtn.disabled = false;
                eventLog.innerHTML = twitterName + ' はどうする?';
                socket.emit('enemyActionEnd', {
                    roomID
                });
            }
        });

        // クリックイベント
        followersBtn.addEventListener('click', followersShowToggle, false);
        skillsBtn.addEventListener('click', skillsShowToggle, false);
        actionContainer.addEventListener('click', selectAction, false);
        enterBtn.addEventListener('click', enterAction, false);

    </script>

  </body>
</html>